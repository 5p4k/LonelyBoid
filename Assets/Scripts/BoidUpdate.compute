#pragma kernel CSMain

struct BoidData {
    uint flockIndex;
    float2 position;
    float2 direction;
    float speed;

    float2 velocity() {
        return speed * direction;
    }

    void setVelocity(float2 v) {
        speed = length(v);
        if (speed > 0.f) {
            direction = v / speed;
        }
    }
};

struct FlockData {
    float viewRadius;
    float viewAngleTau;

    float avoidRadius;
    float avoidAngleTau;

    float separationWeight;
    float alignmentWeight;
    float cohesionWeight;

    float maxAcceleration;
    float minSpeed;
    float maxSpeed;
    float maxAngularSpeedTau;
};

RWStructuredBuffer<BoidData> boidData;
int boidCount;

RWStructuredBuffer<FlockData> flockData;
int flockCount;

float deltaTime;

static const float PI = 3.141592653589793f;


float2 clamp_magnitude(float2 v, float minMagnitude, float maxMagnitude) {
    const float inMagnitude = length(v);
    const float outMagnitude = clamp(inMagnitude, minMagnitude, maxMagnitude);
    if (inMagnitude > 0.f) {
        v *= outMagnitude / inMagnitude;
    }
    return v;
}


float2 safe_normalize(float2 v) {
    const float magnitude = length(v);
    if (magnitude > 0.f) {
        v /= magnitude;
    }
    return v;
}

float cross2(float2 v, float2 w) {
    return v.x * w.y - v.y * w.x;
}


float2 ComputeVelocityChange(float2 direction, float speed, float2 acceleration,
                             float maxAcceleration, float maxAngleRad) {
    const float accelerationMagnitude = length(acceleration);
    float accelerationFactor = deltaTime;

    if (accelerationMagnitude >= 1.e-5f) {
        /*
         * Theoretically, the velocity change is given by v += clamp_magnitude(a, 0, maxAcceleration) * deltaT.
         * This means that the candidates for the velocity change are
         *  - a * deltaT * maxAcceleration / |a|
         *  - a * deltaT
         * whichever is smaller.
         */
        accelerationFactor = min(accelerationFactor, deltaTime * maxAcceleration / accelerationMagnitude);

        // Do we need to reduce the acceleration even further to clamp down on angular speed?
        if (maxAngleRad < PI) {
            // Rotate the current direction by maxAngleRad to obtain the direction that marks the rotation limit
            const float rotCos = cos(maxAngleRad);
            float rotSin = sin(maxAngleRad);

            // Does the acceleration make us rotate clockwise or counterclockwise?
            if (cross2(direction, acceleration) < 0.f) {
                rotSin *= -1.f;
            }

            const float2 maxAngleDir = float2(
                direction.x * rotCos - direction.y * rotSin,
                direction.x * rotSin + direction.y * rotCos
            );

            // Intersect velocity + t * acceleration with the line through maxAngleDir.
            // We calculate the t that yields the intersection.
            const float aCrossMaxAngleDir = cross2(acceleration, maxAngleDir);

            // If it's zero or has the opposite sign as rotSin, there is no intersection for a t > 0.
            // In particular, we will not be exceeding the max angle.
            if (abs(aCrossMaxAngleDir) > 1.e-5f && sign(aCrossMaxAngleDir) != sign(rotSin)) {
                // Scaling acceleration by this factor will keep the angular rotation under check
                // I swear this is correct
                const float scaling = -rotSin * speed / aCrossMaxAngleDir;
                accelerationFactor = min(accelerationFactor, scaling);
            }
        }
    }

    return acceleration * accelerationFactor;
}


[numthreads(1024, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    /*
     * Refer to [Lebar Bajec, Zimic, Mraz, 2007]: "The computational beauty of flocking: boids revisited"
     *
     * Note: most other sources, including the original paper by Reynolds, do not deal with the problem of how to
     * computationally update the velocity. This one paper above instead explains exactly how the boids drives are to
     * be implemented into code.
     */
    const int i = id.x;
    BoidData ithBoid = boidData[i];

    // Reset the properties
    uint matesCount = 0;
    float2 matesMeanPosition = float2(0, 0);
    float2 matesMeanVelocity = float2(0, 0);
    float2 avoidPotential = float2(0, 0);

    const FlockData flock = flockData[ithBoid.flockIndex];

    // Note: 1 tau = 2 pi, thus here we are halving the angle
    const float viewAngleCos = cos(flock.viewAngleTau * PI);
    const float avoidAngleCos = cos(flock.avoidAngleTau * PI);

    for (int j = 0; j < boidCount; ++j) {
        if (i == j) {
            continue;
        }
        // Foreach other boid
        BoidData jthBoid = boidData[j];

        const float2 ijOffset = jthBoid.position - ithBoid.position;
        const float ijDistance = length(ijOffset);
        const float2 ijDirection = ijOffset / ijDistance;

        // The dot product of two normal vector is the cosine of the angle between them
        const float angleCos = dot(ijDirection, ithBoid.direction);

        if (jthBoid.flockIndex == ithBoid.flockIndex) {
            // Same flock, is it in view?
            if (angleCos < viewAngleCos && ijDistance <= flock.viewRadius) {
                // Boids in range and in view that belong to the same flock contribute
                ++matesCount;
                matesMeanPosition += jthBoid.position;
                matesMeanVelocity += jthBoid.velocity();
            }
        }

        // Is in perception for avoidance?
        if (angleCos < avoidAngleCos && ijDistance > 0.f && ijDistance <= flock.avoidRadius) {
            // Other boids only contribute to avoidance in a measure equal to 1 / distance
            avoidPotential -= ijDirection / ijDistance;
        }
    }

    if (matesCount > 0) {
        matesMeanPosition /= matesCount;
        matesMeanVelocity /= matesCount;
    }

    // Compute each drive
    const float2 alignmentDrive = safe_normalize(matesMeanVelocity - ithBoid.velocity());
    const float2 separationDrive = safe_normalize(avoidPotential);
    const float2 cohesionDrive = safe_normalize(matesMeanPosition - ithBoid.position);

    // Compute the weighted acceleration from the drive
    const float2 acceleration = flock.separationWeight * separationDrive
                              + flock.alignmentWeight * alignmentDrive
                              + flock.cohesionWeight * cohesionDrive;

    const float2 deltaVelocity = ComputeVelocityChange(
        ithBoid.direction, ithBoid.speed, acceleration,
        flock.maxAcceleration, flock.maxAngularSpeedTau * deltaTime * 2.f * PI
    );

    // Compute the velocity update
    const float2 velocity = clamp_magnitude(ithBoid.velocity() + deltaVelocity, flock.minSpeed, flock.maxSpeed);
    ithBoid.setVelocity(velocity);

    // Compute the position update
    ithBoid.position += velocity * deltaTime;
    
    // Copy back, there is no references in HLSL
    boidData[i] = ithBoid;
}