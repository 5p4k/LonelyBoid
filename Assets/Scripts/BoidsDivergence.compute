// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CS0
#pragma kernel CS1

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> textureOutput;
RWTexture2D<float4> textureScratch;


float4 textureWindow;
int2 textureSize;

[numthreads(8,8,1)]
void CS0(uint3 id : SV_DispatchThreadID) {
    const float2 pixelSize = float2(textureWindow.z / float(textureSize.x), textureWindow.w / float(textureSize.y));

    float2 c = textureOutput[id.xy].xy;

    const float xph = textureOutput[id.xy + int2(+1, 0)].x;
    const float xmh = textureOutput[id.xy + int2(-1, 0)].x;
    const float yph = textureOutput[id.xy + int2(0, +1)].y;
    const float ymh = textureOutput[id.xy + int2(0, -1)].y;

    const float2 partial = (float2(xph, yph) - 2.f * c + float2(xmh, ymh)) / (pixelSize * pixelSize);

    textureScratch[id.xy] = float4(partial.x + partial.y, 0, 0, 0);
}


[numthreads(8,8,1)]
void CS1(uint3 id : SV_DispatchThreadID) {
    const float divergence = textureScratch[id.xy].x;

    // Color scale: red at -1, white at 0, blue at 1.
    const float mixR = saturate(-divergence);
    const float mixB = saturate(+divergence);
    const float mixW = saturate(1.f - abs(divergence));

    const float4 r = float4(1, 0, 0, 1);
    const float4 b = float4(0, 0, 1, 1);
    const float4 w = float4(1, 1, 1, 1);

    textureOutput[id.xy] = r * mixR + b * mixB + w * mixW;
}

