#pragma kernel main

#include "BoidsLibrary.cginc"

StructuredBuffer<boid_data> boids;
int boid_count;

StructuredBuffer<flock_data> flocks;
int flock_index;

StructuredBuffer<force_data> forces;
int force_count;

float time;
float delta_time;
int stride;

RWStructuredBuffer<float2> orbits;

float2 compute_flow_field_acceleration(const flock_data flock, const float2 position, const float2 direction,
                                       const float local_time)
{
    // A dummy boid that is used to derive the drives
    boid_data dummy;
    dummy.flock_index = flock_index;
    dummy.position = position;
    dummy.direction = direction;
    dummy.speed = 1.f;

    // Compute neighborhood drives: 
    float2 cohesion_drive, separation_drive, alignment_drive;

    neighborhood_drives_calculator drive_calc;
    drive_calc.initialize(dummy, flock);
    for (int i = 0; i < boid_count; ++i)
    {
        drive_calc.update(boids[i]);
    }
    drive_calc.compute(cohesion_drive, separation_drive, alignment_drive);

    // Compute force field drives:
    const float2 survival_drive = compute_survival_drive(dummy, flock);

    // Compute the weighted acceleration from the drive
    float2 acceleration = flock.separation_weight * separation_drive
        + flock.alignment_weight * alignment_drive
        + flock.cohesion_weight * cohesion_drive
        + flock.survival_weight * survival_drive;

    // Apply the external forces
    for (uint k = 0; k < (uint)force_count; ++k)
    {
        force_data force = forces[k];
        acceleration += force.compute(position, local_time);
    }

    return acceleration;
}

[numthreads(1,1,1)]
void main(uint3 id : SV_DispatchThreadID)
{
    flock_data flock = flocks[flock_index];

    // Patch the flock data to allow 360 degrees view and avoidance to remove dependency from orientation
    flock.view_angle_tau = 1.f;
    flock.avoid_angle_tau = 1.f;

    float2 position = orbits[id.x * stride];
    float2 direction = float2(0, 1);
    for (int di = 0; di < stride - 1; ++di)
    {
        const float local_time = time + float(di) * delta_time;
        const float2 acceleration = compute_flow_field_acceleration(flock, position, direction, local_time);
        position += acceleration * delta_time;
        direction = normalize(acceleration);

        orbits[id.x * stride + di + 1] = position;
    }
}
