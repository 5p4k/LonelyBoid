#pragma kernel main

#include "BoidsLibrary.cginc"

StructuredBuffer<BoidData> boid_data;
int boid_count;

StructuredBuffer<FlockData> flock_data;
int flock_index;

StructuredBuffer<ForceData> force_data;
int force_count;

float time;

float4 texture_window;
int2 texture_size;

RWTexture2D<float2> texture_output;


[numthreads(8,8,1)]
void main(uint3 id : SV_DispatchThreadID)
{
    const float2 px_size = float2(texture_window.z / float(texture_size.x), texture_window.w / float(texture_size.y));
    const float2 position = 0.5f * px_size + texture_window.xy + px_size * id.xy;

    FlockData flock = flock_data[flock_index];

    // Patch the flock data to allow 360 degrees view and avoidance to remove
    // dependency from orientation
    flock.viewAngleTau = 1.f;
    flock.avoidAngleTau = 1.f;

    // A dummy boid that is used to derive the drives
    BoidData dummy;
    dummy.flockIndex = flock_index;
    dummy.position = position;
    dummy.direction = float2(0, 1);
    dummy.speed = 1.f;

    // Compute neighborhood drives: 
    float2 cohesion_drive, separation_drive, alignment_drive;

    NeighborhoodDrivesCalculator driveCalc;
    driveCalc.Initialize(dummy, flock);
    for (int i = 0; i < boid_count; ++i)
    {
        driveCalc.Update(boid_data[i]);
    }
    driveCalc.Compute(cohesion_drive, separation_drive, alignment_drive);

    // Compute force field drives:
    const float2 survival_drive = ComputeSurvivalDrive(dummy, flock);

    // Compute the weighted acceleration from the drive
    float2 acceleration = flock.separationWeight * separation_drive
        + flock.alignmentWeight * alignment_drive
        + flock.cohesionWeight * cohesion_drive
        + flock.survivalWeight * survival_drive;

    // Apply the external forces
    for (uint k = 0; k < (uint)force_count; ++k)
    {
        ForceData force = force_data[k];
        acceleration += force.Compute(position, time);
    }

    texture_output[id.xy] = acceleration;
}
