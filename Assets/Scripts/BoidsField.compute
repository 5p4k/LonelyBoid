#pragma kernel CSMain

#include "BoidsLibrary.cginc"

StructuredBuffer<BoidData> boid_data;
int boid_count;

StructuredBuffer<FlockData> flock_data;
int flock_index;

StructuredBuffer<ForceData> force_data;
int force_count;

float time;

float4 texture_window;
int2 texture_size;

RWTexture2D<float2> texture_output;


[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
    const float2 pixelSize = float2(texture_window.z / float(texture_size.x), texture_window.w / float(texture_size.y));
    const float2 position = 0.5f * pixelSize + texture_window.xy + pixelSize * id.xy;

    FlockData flock = flock_data[flock_index];

    // Patch the flock data to allow 360 degrees view and avoidance to remove
    // dependency from orientation
    flock.viewAngleTau = 1.f;
    flock.avoidAngleTau = 1.f;

    // A dummy boid that is used to derive the drives
    BoidData dummy;
    dummy.flockIndex = flock_index;
    dummy.position = position;
    dummy.direction = float2(0, 1);
    dummy.speed = 1.f;

    // Compute neighborhood drives: 
    float2 cohesionDrive, separationDrive, alignmentDrive;

    NeighborhoodDrivesCalculator driveCalc;
    driveCalc.Initialize(dummy, flock);
    for (int i = 0; i < boid_count; ++i) {
        driveCalc.Update(boid_data[i]);
    }
    driveCalc.Compute(cohesionDrive, separationDrive, alignmentDrive);

    // Compute force field drives:
    float2 survivalDrive = ComputeSurvivalDrive(dummy, flock);

    // Compute the weighted acceleration from the drive
    float2 acceleration = flock.separationWeight * separationDrive
                        + flock.alignmentWeight * alignmentDrive
                        + flock.cohesionWeight * cohesionDrive
                        + flock.survivalWeight * survivalDrive;
    
    // Apply the external forces
    for (uint k = 0; k < (uint)force_count; ++k)
    {
        ForceData force = force_data[k];
        acceleration += force.Compute(position, time);
    }

    texture_output[id.xy] = acceleration;
}
