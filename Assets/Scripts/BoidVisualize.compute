#pragma kernel CSMain

#include "BoidsLibrary.cginc"

RWStructuredBuffer<BoidData> boidData;
int boidCount;

RWStructuredBuffer<FlockData> flockData;
int flockIndex;

float4 textureWindow;
int2 textureSize;
float maxValue;

RWTexture2D<float4> textureOutput;

/* Unused currently.

float3 hsl2rgb(float3 hsl) {
    const float3 rgb = saturate(float3(
        abs(hsl.x * 6.f - 3.f) - 1.f,
        2.f - abs(hsl.x * 6.f - 2.f),
        2.f - abs(hsl.x * 6.f - 4.f)
    ));
    const float c = (1.f - abs(2.f * hsl.z - 1.f)) * hsl.y;
    return (rgb - 0.5f) * c + hsl.z;
}
*/


[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
    const float2 pixelSize = float2(textureWindow.z / float(textureSize.x), textureWindow.w / float(textureSize.y));
    const float2 position = 0.5f * pixelSize + textureWindow.xy + pixelSize * float2(id.x, textureSize.y - id.y);

    FlockData flock = flockData[flockIndex];

    // A dummy boid that is used to derive the drives
    BoidData dummy;
    dummy.flockIndex = flockIndex;
    dummy.position = position;
    dummy.direction = float2(0, 1);
    dummy.speed = 1.f;

    // Compute neighborhood drives: 
    float2 cohesionDrive, separationDrive, alignmentDrive;

    NeighborhoodDrivesCalculator driveCalc;
    driveCalc.Initialize(dummy, flock);
    for (int i = 0; i < boidCount; ++i) {
        driveCalc.Update(boidData[i]);
    }
    driveCalc.Compute(cohesionDrive, separationDrive, alignmentDrive);

    // Compute force field drives:
    float2 survivalDrive = ComputeSurvivalDrive(dummy, flock);

    // Compute the weighted acceleration from the drive
    const float2 acceleration = flock.separationWeight * separationDrive
                              + flock.alignmentWeight * alignmentDrive
                              + flock.cohesionWeight * cohesionDrive
                              + flock.survivalWeight * survivalDrive;

    float4 color = float4(0, 0, 0, 0);
    color.xy = acceleration;

    textureOutput[id.xy] = color;
}
