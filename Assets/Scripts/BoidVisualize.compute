#pragma kernel CSMain

#include "BoidsLibrary.cginc"

StructuredBuffer<BoidData> boidData;
int boidCount;

StructuredBuffer<FlockData> flockData;
int flockIndex;

float4 textureWindow;
int2 textureSize;

RWTexture2D<float2> textureOutput;


[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
    const float2 pixelSize = float2(textureWindow.z / float(textureSize.x), textureWindow.w / float(textureSize.y));
    const float2 position = 0.5f * pixelSize + textureWindow.xy + pixelSize * id.xy;

    FlockData flock = flockData[flockIndex];

    // Patch the flock data to allow 360 degrees view and avoidance to remove
    // dependency from orientation
    flock.viewAngleTau = 1.f;
    flock.avoidAngleTau = 1.f;

    // A dummy boid that is used to derive the drives
    BoidData dummy;
    dummy.flockIndex = flockIndex;
    dummy.position = position;
    dummy.direction = float2(0, 1);
    dummy.speed = 1.f;

    // Compute neighborhood drives: 
    float2 cohesionDrive, separationDrive, alignmentDrive;

    NeighborhoodDrivesCalculator driveCalc;
    driveCalc.Initialize(dummy, flock);
    for (int i = 0; i < boidCount; ++i) {
        driveCalc.Update(boidData[i]);
    }
    driveCalc.Compute(cohesionDrive, separationDrive, alignmentDrive);

    // Compute force field drives:
    float2 survivalDrive = ComputeSurvivalDrive(dummy, flock);

    // Compute the weighted acceleration from the drive
    const float2 acceleration = flock.separationWeight * separationDrive
                              + flock.alignmentWeight * alignmentDrive
                              + flock.cohesionWeight * cohesionDrive
                              + flock.survivalWeight * survivalDrive;

    textureOutput[id.xy] = acceleration;
}
