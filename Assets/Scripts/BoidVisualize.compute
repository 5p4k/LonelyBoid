#pragma kernel CSMain

#include "BoidsLibrary.cginc"

RWStructuredBuffer<BoidData> boidData;
int boidCount;

RWStructuredBuffer<FlockData> flockData;
int flockIndex;

float2 texturePosition;
float2 texturePixelSize;
float maxValue;

RWTexture2D<float4> textureOutput;

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
    FlockData flock = flockData[flockIndex];

    // A dummy boid that is used to derive the drives
    BoidData dummy;
    dummy.flockIndex = flockIndex;
    dummy.position = texturePosition + texturePixelSize * id.xy + 0.5 * texturePixelSize;
    dummy.direction = float2(0, 1);
    dummy.speed = 1.f;

    // Compute neighborhood drives: 
    float2 cohesionDrive, separationDrive, alignmentDrive;

    NeighborhoodDrivesCalculator driveCalc;
    driveCalc.Initialize(dummy, flock);
    for (int i = 0; i < boidCount; ++i) {
        driveCalc.Update(boidData[i]);
    }
    driveCalc.Compute(cohesionDrive, separationDrive, alignmentDrive);

    // Compute force field drives:
    float2 survivalDrive = ComputeSurvivalDrive(dummy, flock);

    // Compute the weighted acceleration from the drive
    const float2 acceleration = flock.separationWeight * separationDrive
                              + flock.alignmentWeight * alignmentDrive
                              + flock.cohesionWeight * cohesionDrive
                              + flock.survivalWeight * survivalDrive;
    const float accelerationMagnitude = length(acceleration);


    float4 color;
    color.xy = saturate(float2(0.5f, 0.5f) + 0.5f * acceleration / maxValue);
    color.z = 0.f;
    color.w = accelerationMagnitude > maxValue ? 0.f : 1.f;

    textureOutput[id.xy] = color;
}
