#pragma kernel CSMain

#include "BoidsLibrary.cginc"

RWStructuredBuffer<BoidData> boid_data;
int boid_count;

StructuredBuffer<FlockData> flock_data;
int flock_count;

StructuredBuffer<ForceData> force_data;
int force_count;

float delta_time;
float time;


[numthreads(1024, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    const int i = id.x;

    // Extract current boid
    BoidData boid = boid_data[i];
    const FlockData flock = flock_data[boid.flockIndex];

    // Compute neighborhood drives: 
    float2 cohesionDrive, separationDrive, alignmentDrive;

    NeighborhoodDrivesCalculator driveCalc;
    driveCalc.Initialize(boid, flock);
    for (int j = 0; j < boid_count; ++j) {
        if (i != j) {
            driveCalc.Update(boid_data[j]);
        }
    }
    driveCalc.Compute(cohesionDrive, separationDrive, alignmentDrive);

    // Compute force field drives:
    float2 survivalDrive = ComputeSurvivalDrive(boid, flock);

    // Compute the weighted acceleration from the drive
    float2 acceleration = flock.separationWeight * separationDrive
                        + flock.alignmentWeight * alignmentDrive
                        + flock.cohesionWeight * cohesionDrive
                        + flock.survivalWeight * survivalDrive;

    // Apply the external forces
    for (uint k = 0; k < (uint)force_count; ++k)
    {
        ForceData force = force_data[k];
        acceleration += force.Compute(boid.position, time);
    }

    // Calculate the velocity update by accounting for max angular speed and max acceleration
    const float2 deltaVelocity = ComputeVelocityChange(
        delta_time, boid.direction, boid.speed, acceleration,
        flock.maxAcceleration, flock.maxAngularSpeedTau * delta_time * 2.f * PI
    );

    // Account for velocity limit and apply the velocity update
    const float2 velocity = clamp_magnitude(boid.velocity() + deltaVelocity, flock.minSpeed, flock.maxSpeed);
    boid.setVelocity(velocity);

    // Compute the position update
    boid.position += velocity * delta_time;
    
    // Copy back, there is no references in HLSL
    boid_data[i] = boid;
}