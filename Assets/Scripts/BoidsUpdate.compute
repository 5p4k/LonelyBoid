#pragma kernel main

#include "BoidsLibrary.cginc"

RWStructuredBuffer<boid_data> boids;
int boid_count;

StructuredBuffer<flock_data> flocks;
int flock_count;

StructuredBuffer<force_data> forces;
int force_count;

float delta_time;
float time;


[numthreads(1, 1, 1)]
void main(uint3 id : SV_DispatchThreadID)
{
    const int i = id.x;

    // Extract current boid
    boid_data boid = boids[i];
    const flock_data flock = flocks[boid.flock_index];

    // Compute neighborhood drives: 
    float2 cohesion_drive, separation_drive, alignment_drive;

    neighborhood_drives_calculator drive_calc;
    drive_calc.initialize(boid, flock);
    for (int j = 0; j < boid_count; ++j)
    {
        if (i != j)
        {
            drive_calc.update(boids[j]);
        }
    }
    drive_calc.compute(cohesion_drive, separation_drive, alignment_drive);

    // Compute force field drives:
    const float2 survival_drive = compute_survival_drive(boid, flock);

    // Compute the weighted acceleration from the drive
    float2 acceleration = flock.separation_weight * separation_drive
        + flock.alignment_weight * alignment_drive
        + flock.cohesion_weight * cohesion_drive
        + flock.survival_weight * survival_drive;

    // Apply the external forces
    for (uint k = 0; k < (uint)force_count; ++k)
    {
        force_data force = forces[k];
        acceleration += force.compute(boid.position, time);
    }

    // Calculate the velocity update by accounting for max angular speed and max acceleration
    const float2 deltaVelocity = compute_velocity_change(
        delta_time, boid.direction, boid.speed, acceleration,
        flock.max_acceleration, flock.max_angular_speed_tau * delta_time * 2.f * PI
    );

    // Account for velocity limit and apply the velocity update
    const float2 velocity = clamp_magnitude(boid.velocity() + deltaVelocity, flock.min_speed, flock.max_speed);
    boid.set_velocity(velocity);

    // Compute the position update
    boid.position += velocity * delta_time;

    // Copy back, there is no references in HLSL
    boids[i] = boid;
}
