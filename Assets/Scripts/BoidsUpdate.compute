#pragma kernel CSMain

#include "BoidsLibrary.cginc"

RWStructuredBuffer<BoidData> boidData;
int boidCount;

StructuredBuffer<FlockData> flockData;
int flockCount;

float deltaTime;


[numthreads(1024, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    const int i = id.x;

    // Extract current boid
    BoidData boid = boidData[i];
    const FlockData flock = flockData[boid.flockIndex];

    // Compute neighborhood drives: 
    float2 cohesionDrive, separationDrive, alignmentDrive;

    NeighborhoodDrivesCalculator driveCalc;
    driveCalc.Initialize(boid, flock);
    for (int j = 0; j < boidCount; ++j) {
        if (i != j) {
            driveCalc.Update(boidData[j]);
        }
    }
    driveCalc.Compute(cohesionDrive, separationDrive, alignmentDrive);

    // Compute force field drives:
    float2 survivalDrive = ComputeSurvivalDrive(boid, flock);

    // Compute the weighted acceleration from the drive
    const float2 acceleration = flock.separationWeight * separationDrive
                              + flock.alignmentWeight * alignmentDrive
                              + flock.cohesionWeight * cohesionDrive
                              + flock.survivalWeight * survivalDrive;

    // Calculate the velocity update by accounting for max angular speed and max acceleration
    const float2 deltaVelocity = ComputeVelocityChange(
        deltaTime, boid.direction, boid.speed, acceleration,
        flock.maxAcceleration, flock.maxAngularSpeedTau * deltaTime * 2.f * PI
    );

    // Account for velocity limit and apply the velocity update
    const float2 velocity = clamp_magnitude(boid.velocity() + deltaVelocity, flock.minSpeed, flock.maxSpeed);
    boid.setVelocity(velocity);

    // Compute the position update
    boid.position += velocity * deltaTime;
    
    // Copy back, there is no references in HLSL
    boidData[i] = boid;
}